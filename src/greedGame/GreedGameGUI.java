package greedGame;

import greedGame.model.Dice;
import greedGame.model.DiceState;
import greedGame.model.GreedGameModel;
import greedGame.model.GreedGameModel.ModelState;
import greedGame.model.player.Player;

import javax.swing.JFrame;
import javax.swing.JPanel;
import net.miginfocom.swing.MigLayout;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.Arrays;
import java.util.List;
import java.util.Observable;
import java.util.Observer;

import javax.swing.JButton;
import javax.swing.JComboBox;
import javax.swing.JScrollPane;
import javax.swing.ScrollPaneConstants;
import javax.swing.JTextPane;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.TabSet;
import javax.swing.text.TabStop;

import java.awt.Font;
import java.awt.Toolkit;

/**
 * A window wrapper that implements a game window. It is the standard view for a
 * <code>GreedGameModel</code>, which it can observe. It contains two panels, a
 * game panel and a add player panel, of which only one is shown at a time,
 * depending on the model.
 */
public class GreedGameGUI implements Observer {

	private GreedGameModel model; // The model to observe

	// The GUI is split into two different panels, one for the main game, and
	// one for adding players.
	// The two panels are set as the content pane of the frame in order to
	// display them, one at the time.
	private JFrame frmGreedGame;
	private JPanel gamePanel;
	private JPanel addPlayerPanel;

	// All components that are used after they are created
	private JButton btnAddPlayer;
	private JButton btnRemoveCurrentPlayer;
	private JButton btnRoll;
	private JButton btnBank;
	private JTextPane playerList;
	private JTextPane historyPane;

	private JButton btnCreate;
	private JButton btnReturn;
	private JTextPane playerAddList;
	private JComboBox playerTypeComboBox;

	private JCheckBox[] diceCheckBoxes; // Contains the six check boxes that are
										// used to select dice

	/*
	 * Default application launcher provided by WindowBuilder. We use our own in
	 * GreedGame, but left this here as a reference.
	 * 
	 * 
	 * //** Launch the application.
	 *//*
		 * public static void main(String[] args) { EventQueue.invokeLater(new
		 * Runnable() {
		 * 
		 * @Override public void run() { try { GreedGameGUIExperiment window =
		 * new GreedGameGUIExperiment(); window.frame.setVisible(true); } catch
		 * (Exception e) { e.printStackTrace(); } } }); }
		 */

	/**
	 * Create the GUI with a model to observe. The GUI is added as a observer to
	 * the model.
	 * 
	 * @param model
	 *            The model to observe
	 */
	public GreedGameGUI(GreedGameModel model) {

		this.model = model;
		model.addObserver(this);

		initialize();

		/*
		 * Uncomment one panel here and comment the other in initialize() when
		 * designing using WindowBuilder in Eclipse, or WindowBuilder will not
		 * be able to tell how the window is laid out
		 */

		// displayGamePanel();
		// displayAddPlayerPanel();
	}

	/**
	 * Exposes the <code>Window</code>s setVisible method.
	 * 
	 * @param visible
	 *            <code>true</code> to show the window, <code>false</code> to
	 *            hide it
	 * 
	 * @see javax.swing.JFrame#setVisible(boolean)
	 */
	public void setVisible(boolean visible) {
		frmGreedGame.setVisible(visible);
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {

		// Setup the frame. Generated by WindowBuilder in Eclipse
		frmGreedGame = new JFrame();
		frmGreedGame.setTitle("Greed Game");
		frmGreedGame.setBounds(100, 100, 740, 460);
		// Custom handling on close, but dispose it
		frmGreedGame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);

		// Split up initialization of the two separate panels
		initializeGamePanel();
		initializeAddPlayerPanel();

		// Initial update of the window, should overwrite all place-holder
		// values
		update(model, null);
	}

	/**
	 * The game panel's part of the initialization. Sets up all its components
	 * and sets some place-holder values used when designing. Most of the
	 * content is generated by WindowBuilder in Eclipse.
	 */
	private void initializeGamePanel() {

		gamePanel = new JPanel();
		gamePanel.setLayout(null); // Absolute layout

		// Sub-panel containing the dice check boxes
		JPanel dicePanel = new JPanel();
		dicePanel.setBounds(10, 11, 81, 400);
		gamePanel.add(dicePanel);
		dicePanel.setLayout(new MigLayout("", "[]", "[][][][][][][][][][][]"));

		{
			// Collects the individual check boxes into an array
			diceCheckBoxes = new JCheckBox[6];

			JCheckBox diceCheckbox1 = new JCheckBox("A");
			diceCheckbox1.setFont(new Font("Tahoma", Font.PLAIN, 24));
			dicePanel.add(diceCheckbox1, "cell 0 0");
			diceCheckBoxes[0] = diceCheckbox1;

			JCheckBox diceCheckbox2 = new JCheckBox("B");
			diceCheckbox2.setFont(new Font("Tahoma", Font.PLAIN, 24));
			dicePanel.add(diceCheckbox2, "cell 0 2");
			diceCheckBoxes[1] = diceCheckbox2;

			JCheckBox diceCheckbox3 = new JCheckBox("C");
			diceCheckbox3.setFont(new Font("Tahoma", Font.PLAIN, 24));
			dicePanel.add(diceCheckbox3, "cell 0 4");
			diceCheckBoxes[2] = diceCheckbox3;

			JCheckBox diceCheckbox4 = new JCheckBox("D");
			diceCheckbox4.setFont(new Font("Tahoma", Font.PLAIN, 24));
			dicePanel.add(diceCheckbox4, "cell 0 6");
			diceCheckBoxes[3] = diceCheckbox4;

			JCheckBox diceCheckbox5 = new JCheckBox("E");
			diceCheckbox5.setFont(new Font("Tahoma", Font.PLAIN, 24));
			dicePanel.add(diceCheckbox5, "cell 0 8");
			diceCheckBoxes[4] = diceCheckbox5;

			JCheckBox diceCheckbox6 = new JCheckBox("F");
			diceCheckbox6.setFont(new Font("Tahoma", Font.PLAIN, 24));
			dicePanel.add(diceCheckbox6, "cell 0 10");
			diceCheckBoxes[5] = diceCheckbox6;
		}

		// Buttons
		{
			// Button for humans to roll the dice
			btnRoll = new JButton("Roll");
			btnRoll.setBounds(101, 388, 361, 23);
			gamePanel.add(btnRoll);

			// Button for humans to bank
			btnBank = new JButton("Bank");
			btnBank.setBounds(101, 354, 361, 23);
			gamePanel.add(btnBank);

			// Button for removing the currently playing player
			btnRemoveCurrentPlayer = new JButton("Remove Current Player");
			btnRemoveCurrentPlayer.setBounds(472, 388, 242, 23);
			gamePanel.add(btnRemoveCurrentPlayer);

			// Button for switching to the add player panel
			btnAddPlayer = new JButton("Add New Player");
			btnAddPlayer.setBounds(472, 354, 242, 23);
			gamePanel.add(btnAddPlayer);
		}

		JLabel lblPlayers = new JLabel("Players");
		lblPlayers.setBounds(472, 11, 46, 14);
		gamePanel.add(lblPlayers);

		// Adds a vertical scroll bar to the player list
		JScrollPane playerListScrollPane = new JScrollPane();
		playerListScrollPane.setBounds(472, 35, 242, 308);
		playerListScrollPane
				.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		gamePanel.add(playerListScrollPane);

		{
			playerList = new JTextPane();
			playerList.setText("mimimimi");
			playerList.setEditable(false);

			// Replace the standard tab stops with a single one appropriate for
			// displaying a players name and score in separate columns.
			// Not handled by WindowDesigner
			Style style = playerList.getLogicalStyle();
			StyleConstants.setTabSet(style, new TabSet(
					new TabStop[] { new TabStop(180) }));
			playerList.setLogicalStyle(style);

			playerListScrollPane.setViewportView(playerList);
		}

		JLabel lblHistory = new JLabel("History");
		lblHistory.setBounds(101, 11, 46, 14);
		gamePanel.add(lblHistory);

		// Adds a vertical scroll bar to the history pane
		JScrollPane historyScrollPane = new JScrollPane();
		historyScrollPane.setBounds(101, 35, 361, 308);
		gamePanel.add(historyScrollPane);

		{
			historyPane = new JTextPane();
			historyPane.setEditable(false);
			historyScrollPane.setViewportView(historyPane);
			historyPane.setText("muu");
		}
	}

	/**
	 * The add player panel's part of the initialization. Sets up all its
	 * components and sets some place-holder values used when designing. Most of
	 * the content is generated by WindowBuilder in Eclipse.
	 */
	private void initializeAddPlayerPanel() {

		addPlayerPanel = new JPanel();
		addPlayerPanel.setLayout(null); // Absolute layout

		JLabel labelPlayerType = new JLabel("Player type");
		labelPlayerType.setBounds(10, 139, 66, 14);
		addPlayerPanel.add(labelPlayerType);

		// Combo box for choosing which type of player to add. Filled with
		// values later in the program.
		playerTypeComboBox = new JComboBox();
		playerTypeComboBox.setBounds(10, 164, 245, 23);
		addPlayerPanel.add(playerTypeComboBox);

		// Buttons for creating player and for returning to the game
		{
			btnCreate = new JButton("Create Player");
			btnCreate.setBounds(10, 39, 245, 72);
			addPlayerPanel.add(btnCreate);

			btnReturn = new JButton("Return to Game");
			btnReturn.setBounds(422, 388, 292, 23);
			addPlayerPanel.add(btnReturn);
		}

		JLabel lblPlayers = new JLabel("Players");
		lblPlayers.setBounds(422, 11, 46, 14);
		addPlayerPanel.add(lblPlayers);

		// Adds a vertical scroll bar to the player list
		JScrollPane playerAddListScrollPane = new JScrollPane();
		playerAddListScrollPane
				.setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_NEVER);
		playerAddListScrollPane.setBounds(422, 39, 292, 338);
		addPlayerPanel.add(playerAddListScrollPane);

		{
			// Later filled with a list of the currently playing players
			playerAddList = new JTextPane();
			playerAddList.setEditable(false);
			playerAddList.setText("mimimimi");

			// Replace the standard tab stops with a single one in order to
			// display players' names and scores in nice columns
			Style style = playerAddList.getLogicalStyle();
			StyleConstants.setTabSet(style, new TabSet(
					new TabStop[] { new TabStop(180) }));
			playerAddList.setLogicalStyle(style);

			playerAddListScrollPane.setViewportView(playerAddList);
		}
	}

	/**
	 * Adds a listener for when the user wishes to start adding players
	 * 
	 * @param actionListener
	 *            The listener to be called when the user wants to start adding
	 *            players
	 */
	public void addAddPlayerActionListener(ActionListener actionListener) {
		btnAddPlayer.addActionListener(actionListener);
	}

	/**
	 * Adds a listener for when the user wishes to remove the currently playing
	 * player
	 * 
	 * @param actionListener
	 *            The listener to be called when the user wants to remove the
	 *            player
	 */
	public void addRemoveCurrentPlayerActionListener(
			ActionListener actionListener) {
		btnRemoveCurrentPlayer.addActionListener(actionListener);
	}

	/**
	 * Adds a listener for when the user wishes to roll the dice
	 * 
	 * @param actionListener
	 *            The listener to be called when the user wants to roll
	 */
	public void addRollActionListener(ActionListener actionListener) {
		btnRoll.addActionListener(actionListener);
	}

	/**
	 * Adds a listener for when the user wishes to bank his score
	 * 
	 * @param actionListener
	 *            The listener to be called when the player wants to bank
	 */
	public void addBankActionListener(ActionListener actionListener) {
		btnBank.addActionListener(actionListener);
	}

	/**
	 * Adds a listener for when one of the check boxes that represents a dice is
	 * selected or unselected. The actual selected check box is passed in a
	 * <code>ActionEvent</code> back to the listener.
	 * 
	 * @param actionListener
	 *            The listener that will be notified when a check box is
	 *            selected or unselected
	 */
	public void addAllDiceCheckBoxActionListener(ActionListener actionListener) {
		for (JCheckBox checkBox : diceCheckBoxes)
			checkBox.addActionListener(actionListener);
	}

	/**
	 * Adds a listener for when a player is to be created. The type of player
	 * desired can be found with <code>getSelectedPlayerType()</code>.
	 * 
	 * @param actionListener
	 *            The listener that will handle creating new players
	 */
	public void addCreatePlayerActionListener(ActionListener actionListener) {
		btnCreate.addActionListener(actionListener);
	}

	/**
	 * Adds a listener for when the user wants to return to the game after
	 * adding player.
	 * 
	 * @param actionListener
	 *            The listener to be called when the return button is pressed
	 */
	public void addReturnActionListener(ActionListener actionListener) {
		btnReturn.addActionListener(actionListener);
	}

	/**
	 * Add a listener for window events. Called when the window is closing or
	 * changed.
	 * 
	 * @param windowListener
	 *            The listener that will handle the window close event
	 */
	public void addWindowListener(WindowListener windowListener) {
		frmGreedGame.addWindowListener(windowListener);
	}

	/**
	 * Sets the player types that the window will allow to be selected for a new
	 * player.
	 * 
	 * @param playerTypes
	 *            An array of <code>String</code>s or similar, that represents
	 *            the available player types.
	 */
	public void setPlayerTypes(Iterable<String> playerTypes) {
		playerTypeComboBox.removeAllItems();
		for (String playerType : playerTypes)
			playerTypeComboBox.addItem(playerType);
	}

	/**
	 * Gets the currently selected player type that should be used when a new
	 * player is created.
	 * 
	 * @return A <code>String</code> representation of the selected player type
	 */
	public String getSelectedPlayerType() {
		return (String) playerTypeComboBox.getSelectedItem();
	}

	/*
	 * (non-Javadoc)
	 * 
	 * Called when the observed model changes, update() is responsible for
	 * keeping the GUI in sync with the model.
	 * 
	 * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
	 */
	@Override
	public void update(Observable o, Object arg) {

		// If, for some reason, the update method is called with some other
		// object than the observed model, ignore it
		if (o != model)
			return;

		// Depending on the state of the model, the GUI looks different
		switch (model.getState()) {

		// The model is in the main game states
		case WAITING_FOR_FIRST_ROLL:
		case WAITING_FOR_PLAYER_DECISION:
			updateGamePanel();
			break;

		// The model is in the add player state
		case ADD_PLAYER:
			displayAddPlayerPanel();

			playerAddList.setText(buildPlayerList());

			break;

		// The model has finished
		case GAME_OVER:

			// Raise an event equal to the user manually closing the window.
			WindowEvent windowEvent = new WindowEvent(frmGreedGame,
					WindowEvent.WINDOW_CLOSING);
			Toolkit.getDefaultToolkit().getSystemEventQueue()
					.postEvent(windowEvent);

			// Actually closing the window, in case the event was not handled
			frmGreedGame.dispose();

			break;
		}
	}

	/**
	 * Updates the contents of the main game panel after setting it to show
	 */
	private void updateGamePanel() {

		// Displays the game panel
		displayGamePanel();

		// Is the player playing using the GUI?
		boolean localPlayer = model.isCurrentPlayerLocalGUI();
		// Is the player local and has selected enough dice to decide?
		boolean canPlayerDecide = model.canDecide() && localPlayer;

		// Depending on the models state, different actions are allowed
		if (model.getState() == ModelState.WAITING_FOR_FIRST_ROLL) {

			// Before the player start his turn by rolling the dice, it is
			// allowed to add or remove players
			btnAddPlayer.setEnabled(true);
			btnRemoveCurrentPlayer.setEnabled(true);

			// If the player is a local human player, he/she must be allowed to
			// roll
			btnRoll.setEnabled(localPlayer);

			// The player can never bank before rolling
			btnBank.setEnabled(false);

		} else {

			// Adding or removing players is not allowed during a players turn
			btnAddPlayer.setEnabled(false);
			btnRemoveCurrentPlayer.setEnabled(false);

			// Rolling and banking requires the player to be a local human
			// player as well as selecting a valid set of dice
			btnRoll.setEnabled(canPlayerDecide);
			btnBank.setEnabled(canPlayerDecide);
		}

		// Get the dice from the model. It is not allowed to modify them
		// directly!
		List<Dice> dice = model.getDice();

		// Step through the dice and alter its corresponding check box according
		// to the state of the dice
		int i = 0;
		for (Dice d : dice) {
			DiceState dState = d.getState();

			// A selected dice is shown with a selected box
			diceCheckBoxes[i].setSelected(dState == DiceState.SELECTED);

			// A box is disabled if the dice is reserved from a previous roll.
			// Also, only a local human player may use the check boxes to select
			// dice,
			// to prevent a human disturbing the actions of a non-human player
			diceCheckBoxes[i].setEnabled(dState != DiceState.RESERVED
					&& model.isCurrentPlayerLocalGUI());

			// The value of the dice is shown as the text of the box
			diceCheckBoxes[i].setText(Integer.toString(d.getValue()));

			i++;
		}

		// Update the history and the player list
		playerList.setText(buildPlayerList());
		historyPane.setText(buildHistory());
	}

	/**
	 * Gets a list of players from the model and turns it into a
	 * newline-separated formatted list fit for display in a text pane.
	 * 
	 * @return The <code>String</code> constructed by concatenating all players,
	 *         separated by newlines.
	 */
	private String buildPlayerList() {

		StringBuilder playerStats = new StringBuilder();

		// For each player, append a formatted line
		for (Player p : model.getPlayers())
			playerStats.append(p.getName() + "\t" + p.getScore() + "\n");

		// Remove the newline after the the last player, only if any players
		if (playerStats.length() > 0)
			playerStats.deleteCharAt(playerStats.length() - 1);

		return playerStats.toString();
	}

	/**
	 * Gets the log from the model and turns it into a newline-separated list
	 * fit for display in a text pane.
	 * 
	 * @return The <code>String</code> constructed by concatenating all log
	 *         entries, separated by newlines.
	 */
	private String buildHistory() {

		StringBuilder history = new StringBuilder();

		// For each log entry, append a line
		for (String s : model.getLog())
			history.append(s + "\n");

		// If any log, remove the last newline
		if (history.length() > 0)
			history.deleteCharAt(history.length() - 1);

		return history.toString();
	}

	/**
	 * Gets the check boxes as a list to enable pairing a
	 * <code>ActionEvent</code> to the selected or unselected check box that
	 * caused it. Do not rely on the order, even if it is not likely to change.
	 * 
	 * @return The check boxes in the GUI that represents dice
	 */
	public List<JCheckBox> getDiceCheckBoxes() {
		return Arrays.asList(diceCheckBoxes);
	}

	/**
	 * Sets the game panel as the content pane of the frame.
	 */
	public void displayGamePanel() {
		frmGreedGame.setContentPane(gamePanel);
	}

	/**
	 * Sets the add player panel as the content pane of the frame
	 */
	public void displayAddPlayerPanel() {
		frmGreedGame.setContentPane(addPlayerPanel);
	}

	/**
	 * Disposes the underlying <code>JFrame</code>
	 * 
	 * @see javax.swing.JFrame#dispose() 
	 */
	public void dispose() {
		frmGreedGame.dispose();
	}
}
